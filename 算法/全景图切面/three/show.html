<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>show</title>
        <script src="http://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
        <script src="tween.umd.js"></script>
        <script src="three.min.js"></script>
        <script src="ThreeBSP.js"></script>
        <script src="OrbitControls.js"></script>
        <script src="data.js"></script>
        <script src="yj_common.js"></script>
        <script src="yj_player.js"></script>
    </head>
    <body>
        <div id="container"></div>
        <button style="position:absolute;right:10px;bottom:10px;" onclick="toggleModel()">模型</button>
        <script>
            var ofloor;
            var inRoom = true, curRoom = "";
            var house = new Array();
            var container = document.getElementById('container');
            var yjCommon = new yj_common();
            var yjPlayer = new yj_player({container: container});
            var pano = yjCommon.getQueryVariable('pano');
            curRoom = 'pano1';
            initEvent();
            yjPlayer.initScene();
            yjPlayer.initControls();
            drawHouse();
            animate();
            function drawHouse() {
                var pa = null;
                if (pano == 'all') {
                    pa = panos;
                    $.each(pa, function (pano, data) {
                        drawRome(pano, data);
                    })
                } else {
                    drawRome(pano, panos[pano]);
                }
            }
            function drawRome(pano, data) {
                var offset = data.offset;
                var group = new THREE.Group();
                group.name = pano;
                addAroudFaces(group, pano, data);
                addFloor(group, pano, data);
                group.position.x = offset[0];
                group.position.z = offset[2];
                group.rotation.y = data.rata;
                yjPlayer.scene.add(group);
                house[pano] = group;
//            addTop();
            }
            function addAroudFaces(group, pano, data) {
                var points = data.points;
                var jiaos = data.jiaos;
                var offset = data.offset;
                for (var i = 0; i < points.length; i++) {
                    let next = (i + 1 == points.length ? 0 : i + 1);
                    let center = yjCommon.getCenter(points[i], points[next]);
                    let width = yjCommon.disXYZ(points[i], points[next]);
                    let height = yjCommon.disXYZ(points[i], [points[i][0], -points[i][1], points[i][2]]);
                    //addPlane(center,width, height,jiaos[i]);
                    var face = yjPlayer.addImgFace("../" + pano + '/' + pano + '_' + i + ".png", center, width, height, jiaos[i]);
                    face.name = pano + '_face_' + i;
                    face.group_name = pano;
                    group.add(face);
                }
            }
            function addTop(group, pano, data) {
            }

            function addFloor(group, pano, data) {
                var points = data.points;
                var floor_wh = data.floors.wh;
//                var center = yjCommon.getPointsCenter(points, offset);
//                var ofloor = yjPlayer.addFloorFace("../" + pano + '/' + pano + "_floor.png", center, floor_wh[0], floor_wh[1], data.floors.rz);
//                ofloor.name = pano + '_floor';
//                ofloor.group_name = pano;
//                group.add(ofloor);
//                return;
                var shaPoint = [];
                for (var i = 0; i < points.length; i++) {
                    shaPoint.push(new THREE.Vector2(points[i][0], points[i][2]));//保证顺序，依次push
                }
                var shape = new THREE.Shape(shaPoint);
                var geometry = new THREE.ShapeGeometry(shape);

                var texture = new THREE.TextureLoader().load("../" + pano + '/' + pano + "_floor.png");
//                texture.wrapT = THREE.RepeatWrapping;
//                texture.repeat.y = -1;
//                texture.repeat.set(0.1, 0.1);
//                texture.offset = new THREE.Vector2(1, 1);
//                texture.rotation = Math.PI;
                var material = new THREE.MeshBasicMaterial({map: texture, side: THREE.DoubleSide});//side: THREE.DoubleSide 两面可见
                assignUVs(geometry, data);

                var floor = new THREE.Mesh(geometry, material);
                floor.position.set(0, -4, 0);
                floor.rotation.x = Math.PI / 2;
                floor.name = pano + '_floor';
                floor.group_name = pano;
                group.add(floor);
//                yjPlayer.addPolygon(points, offset);
            }
            function assignUVs(geometry, data) {
                var tx_w = data.floors.wh[0];
                var tx_h = data.floors.wh[1];
                var tx_pts = data.floors.points;
                var pM = [tx_pts[0][0], tx_pts[0][2]];
                var pL = [tx_pts[1][0], tx_pts[1][2]];
                var pQ = [tx_pts[2][0], tx_pts[2][2]];
                var len_ML = yjCommon.disXY(pM, pL);
                var len_LQ = yjCommon.disXY(pL, pQ);
                var faces = geometry.faces;
//                console.log(pM, pL, pQ, len_ML, len_LQ, tx_w, tx_h, geometry.vertices);
                console.log(geometry.vertices)
                geometry.faceVertexUvs[0] = [];
                for (var i = 0; i < faces.length; i++) {
                    var v1 = geometry.vertices[faces[i].a], v2 = geometry.vertices[faces[i].b], v3 = geometry.vertices[faces[i].c];
                    var pV1 = getNewXY(pM, pL, pQ, v1, len_ML, len_LQ, tx_w, tx_h);
                    var pV2 = getNewXY(pM, pL, pQ, v2, len_ML, len_LQ, tx_w, tx_h);
                    var pV3 = getNewXY(pM, pL, pQ, v3, len_ML, len_LQ, tx_w, tx_h);
//                    console.log(pV1, pV2, pV3);
                    geometry.faceVertexUvs[0].push([pV1, pV2, pV3]);
                }
                geometry.uvsNeedUpdate = true;
            }
            function getNewXY(pM, pL, pQ, pH, len_ML, len_LQ, tx_w, tx_h) {
                var area_HML = yjCommon.areaXY(pM, pL, [pH.x, pH.y]);
                var len_H_ML = area_HML / len_ML * 2;
                var area_HLQ = yjCommon.areaXY(pL, pQ, [pH.x, pH.y]);
                var len_H_LQ = area_HLQ / len_LQ * 2;
                return new THREE.Vector2(1 - len_H_LQ / tx_w, 1 - len_H_ML / tx_h);
            }

            function initEvent() {
                window.addEventListener('resize', yjPlayer.onWindowResize, false);
                document.addEventListener('click', onClick, false);
            }
            function onClick(event) {
                var selectLine = yjPlayer.getClickObj(event.clientX, event.clientY);
                for (var i = 0; i < selectLine.length; i++) {
                    let obj = selectLine[i][0].object;
                    if (!inRoom) {
                    } else if (obj.group_name != curRoom) {
                        inRoom = true;
                        curRoom = obj.group_name;
                        yjPlayer.animateCamera(panos[obj.group_name].offset);
                        return;
                    }
                }
            }
            function animate() {
                requestAnimationFrame(animate);
                TWEEN.update();
                if (yjPlayer.controls) {
                    yjPlayer.controls.update();
                }
                yjPlayer.renderer.render(yjPlayer.scene, yjPlayer.camera);
            }
            function toggleModel() {
                if (!inRoom) {
                    yjPlayer.camera.position.set(0, 0, 0);
                    inRoom = true;
                } else {
                    yjPlayer.camera.position.set(15, 5, 15);
                    inRoom = false;
                }
            }
        </script>

    </body>
</html>