<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>show</title>
    <style>
        #container{
            width: 100%;
            height: 800px;
        }
    </style>
    <script src="three.js"></script>
    <script src="data.js"></script>
</head>
<body>
    <div id="container"></div>
    <script>
			var camera, scene, renderer;
			var mesh;
			var container = document.getElementById( 'container' );
			var bili=1;
			initEvent();
			initScene();
			addPanos();
			animate();
			
			function initScene(){
				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );
				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera( 120, window.innerWidth / window.innerHeight, 0.1, 10000 );
				camera.position.set(0,0,0);
			}
			function addPanos() {
				for(var i=0;i<points.length;i++){
					let next=(i+1==points.length?0:i+1);
					let center=getCenter(points[i],points[next]);
					let width=distance(points[i],points[next]);
					let height=distance(points[i],[points[i][0],-points[i][1],points[i][2]]);
					console.log(height);
					//addPlane(center,width, height,jiaos[i]);
					addPano("x"+i+".png",center,width, height,jiaos[i],width[i]);
				}
			}
			function addPano(img,center,width, height,jiao){
				var texture=new THREE.TextureLoader().load( img);
				var material = new THREE.MeshBasicMaterial( { map: texture } );
				var quad = new THREE.PlaneBufferGeometry( width, height );
				var face = new THREE.Mesh( quad, material );
				face.position.set(center[0]*bili,center[1]*bili,center[2]*bili);
				face.rotation.y =jiao;
				scene.add( face );
			}
			function addPlane(center,width, height,jiao){
				let plane = new THREE.Mesh(new THREE.PlaneGeometry(width, height),
					new THREE.MeshBasicMaterial({
						color: 0xff0000,
						wireframe: true
					})
				)
				plane.position.set(center[0]*bili,center[1]*bili,center[2]*bili);
				plane.rotation.y =jiao;
				scene.add(plane);
			}
			
			function addALine(startPoint,endPoint,color=0xFF0000){
				var geometry = new THREE.Geometry();
				geometry.vertices.push(new THREE.Vector3(startPoint[0],startPoint[1],startPoint[2]),new THREE.Vector3(endPoint[0],endPoint[1],endPoint[2]));
                var material = new THREE.MeshBasicMaterial();
				material = new THREE.LineBasicMaterial({ color:color });
				var line = new THREE.Line(geometry, material);
				scene.add(line);
			}
			function getCenter(pA,pB){
				var pC=[pA[0],-pA[1],pA[2]];
				var pD=[pB[0],-pB[1],pB[2]];
				return [(pA[0]+pC[0]+pB[0]+pD[0])/4,(pA[1]+pC[1]+pB[1]+pD[1])/4,(pA[2]+pC[2]+pB[2]+pD[2])/4];
			}
			
			function distance(pA, pB) {
				return Math.sqrt(Math.pow(pB[0] - pA[0], 2) + Math.pow(pB[1] - pA[1], 2) + Math.pow(pB[2] - pA[2], 2));
			}
			function r2d(rad) {
				return rad * 180 / Math.PI;
			}
			function d2r(degree){
				return degree * Math.PI / 180;
			}
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			function animate() {
				requestAnimationFrame( animate );
				renderer.render( scene, camera );
			}
			
			function initEvent() {
 
				window.addEventListener( 'resize', onWindowResize, false );
				
				var bMouseDown = false;
				var x = -1;
				var y =-1;
				container.onmousedown=function(event){
					event.preventDefault();
					x=event.clientX;
					y=event.clientY;
					bMouseDown = true;
				}
				container.onmouseup=function(event){
					event.preventDefault();
					bMouseDown = false;
				}
				container.onmousemove=function(event){
					event.preventDefault();
					if(bMouseDown)
					{
						camera.rotation.y += -0.005*(event.clientX-x);
						camera.rotation.x += -0.005*(event.clientY-y);
						
						x=event.clientX;
						y=event.clientY;
					}
				}
				container.onmousewheel=function(event){
					event.preventDefault();
					if(event.wheelDelta!=0){
						camera.fov+=event.wheelDelta>0?1:-1;
						if(camera.fov>150)
						{
						  camera.fov=150;
						}
						else if(camera.fov < 30)
						{
							camera.fov = 30;
						}
						camera.updateProjectionMatrix();
					}
				}
				document.onkeydown=function(e){
					var e = e || window.event;  //标准化事件处理
					console.log(e.keyCode);
					switch(e.keyCode){
						case 37://左
							camera.position.x--;
							break;
						case 38://上
							camera.position.y++;
							break;
						case 39://右
							camera.position.x++;
							break;
						case 4://下
							camera.position.y--;
							break;
						case 83://s
							camera.position.z++;
							break;
						case 87://w
							camera.position.z--;
							break;
					}
					//var worldPosition = new THREE.Vector3();
					//cube.getWorldPosition(worldPosition)
					//console.log('原始顶点坐标',cube.geometry.vertices);
				}
			}
    </script>
 
</body>
</html>